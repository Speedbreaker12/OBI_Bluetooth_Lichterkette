const { exec } = require('child_process');

// **Konstanten**
const MAX_RETRIES = 10;
let bluetoothAdapter = 'hci0';
const deviceAddress = '24:35:02:27:DE:6E';
const characteristicHandle = '0x0025';
const datapointOnOff = 'javascript.0.MeineVariablen.Lichterkette_OnOff';
const datapointBrightness = 'javascript.0.MeineVariablen.Lichterkette_Helligkeit';
const pushoverDevice = 'iphone-Fabian';

const actionQueue = [];
let isProcessing = false;
let isResetting = false;

// Funktion: Bluetooth-Adapter aktivieren
function activateBluetoothAdapter() {
    return new Promise((resolve, reject) => {
        exec(`hciconfig ${bluetoothAdapter} up`, (error, stdout, stderr) => {
            if (error) {
                log(`Fehler beim Aktivieren des Adapters ${bluetoothAdapter}: ${stderr || error.message}`, 'error');
                return reject(`Adapter ${bluetoothAdapter} konnte nicht aktiviert werden.`);
            }
            log(`Bluetooth-Adapter ${bluetoothAdapter} aktiviert: ${stdout.trim()}`, 'info');
            resolve();
        });
    });
}

// Funktion: Shell-Befehl ausführen
function executeCommand(command, timeout = 20000) {
    return new Promise((resolve, reject) => {
        const process = exec(command, (error, stdout, stderr) => {
            if (error) {
                clearTimeout(timeoutId);

                const warningErrors = [
                    "Device or resource busy",
                    "Function not implemented",
                    "Software caused connection abort"
                ];

                const isWarningError = warningErrors.some((warning) =>
                    (stderr || error.message).includes(warning)
                );

                const logLevel = isWarningError ? 'warn' : 'error';
                log(`Fehler beim Ausführen des Befehls: ${stderr || error.message}`, logLevel);
                return reject(stderr || error.message);
            }
            clearTimeout(timeoutId);
            resolve(stdout.trim());
        });

        const timeoutId = setTimeout(() => {
            if (!process.killed) process.kill('SIGTERM');
            reject('Befehl abgebrochen (Timeout)');
        }, timeout);
    });
}

// Funktion: GATT-Wert schreiben
async function writeGattValue(value) {
    const command = `gatttool -i ${bluetoothAdapter} -b ${deviceAddress} --char-write-req --handle=${characteristicHandle} --value="${value}"`;
    return executeCommand(command);
}

// Wiederholtes Schreiben mit Validierung und Logging
async function writeGattValueWithRetries(value, oldValue, datapoint, initialDelay = 5000) {
    if (!datapoint) {
        log('Fehler: Datenpunkt ist nicht definiert!', 'error');
        throw new Error('Datenpunkt für writeGattValueWithRetries ist undefined.');
    }

    let attempts = 0;
    let delay = initialDelay;

    while (attempts < MAX_RETRIES) {
        try {
            log(`Start von writeGattValueWithRetries für Wert: ${value}`, 'debug');
            log(`Versuch ${attempts + 1}/${MAX_RETRIES}: Sende GATT-Wert`, 'info');
            await writeGattValue(value);
            log('GATT-Wert erfolgreich gesendet.', 'info');
            return;
        } catch (error) {
            attempts++;
            log(`Warnung beim Senden (Versuch ${attempts}/${MAX_RETRIES}): ${error}`, 'warn');
            if (attempts >= MAX_RETRIES) {
                log('Maximale Anzahl an Versuchen erreicht. Abbruch.', 'error');

                // Sicheres Zurücksetzen
                if (oldValue !== undefined && oldValue !== null) {
                    isResetting = true;
                    setState(datapoint, oldValue, true);
                    log(`Datenpunkt "${datapoint}" auf den alten Wert zurückgesetzt: ${oldValue}`, 'info');
                    isResetting = false;
                } else {
                    log(`Fehler: Alter Wert für "${datapoint}" ist undefined oder null. Kein Zurücksetzen möglich.`, 'error');
                }

                sendPushoverNotification(
                    `Befehl konnte nach ${MAX_RETRIES} Versuchen nicht gesendet werden: ${value}`
                );
                throw new Error('GATT-Befehl konnte nach mehreren Versuchen nicht gesendet werden.');
            }
            await new Promise((resolve) => setTimeout(resolve, delay));
            delay *= 1.1;
        }
    }
}

async function processQueue() {
    if (isProcessing) {
        log('Warteschlange wird bereits verarbeitet. Vorgang abgebrochen.', 'debug');
        return;
    }

    if (actionQueue.length === 0) {
        log('Warteschlange ist leer. Keine Aktionen zu verarbeiten.', 'info');
        isProcessing = false;
        return;
    }

    log('Beginne Verarbeitung der Warteschlange...', 'info');
    isProcessing = true;

    while (actionQueue.length > 0) {
        const { action, brightness } = actionQueue[0]; // Verarbeite immer das erste Element der Warteschlange

        try {
            await controlLight(action, brightness);
            actionQueue.shift(); // Entferne die Aktion nach erfolgreicher Verarbeitung
        } catch (error) {
            log(`Fehler beim Abarbeiten der Warteschlange: ${error}`, 'error');
        }
    }

    log('Verarbeitung der Warteschlange abgeschlossen.', 'info');
    isProcessing = false; // Setze den Status korrekt zurück
}

// Kontrolle der Lampe (On/Off oder Helligkeit)
async function controlLight(action, brightness = null) {
    try {
        if (action) {
            if (brightness !== null) {
                const brightnessValue = calculateBrightnessHex(brightness);
                await writeGattValueWithRetries(brightnessValue, null, datapointBrightness);
            } else {
                const value = action === 'on' ? '01010101' : '01010100';
                await writeGattValueWithRetries(value, null, datapointOnOff);
            }
        }
    } catch (error) {
        throw error;
    }
}

function sendPushoverNotification(message) {
    sendTo("pushover", {
        message: message,
        title: "Lichterkette Fehler",
        device: pushoverDevice
    });
}

function calculateBrightnessHex(brightnessPercent) {
    return `030101${Math.round((brightnessPercent / 100) * 0x64).toString(16).padStart(2, '0')}`;
}

on({ id: datapointOnOff, change: 'ne' }, async (obj) => {
    if (isResetting || obj.state.ack) return;

    const desiredState = obj.state.val;

    // Debug-Logs für `obj.oldState`
    log(`Trigger ausgelöst für On/Off:`, 'info');
    log(`- Alter Zustand (obj.oldState): ${JSON.stringify(obj.oldState)}`, 'debug');
    log(`- Alter Wert (obj.oldState.val): ${obj.oldState?.val}`, 'debug');
    log(`- Neuer Wert (obj.state.val): ${desiredState}`, 'debug');

    const oldOnOffValue = obj.oldState?.val ?? getState(obj.id)?.val ?? false;

    log(`- Verwendeter alter On/Off-Wert (Fallback berücksichtigt): ${oldOnOffValue}`, 'debug');

    if (desiredState === oldOnOffValue) return;

    const actionExists = actionQueue.some((entry) => entry.action === (desiredState ? 'on' : 'off'));
    if (actionExists) {
        log('Aktion bereits in der Warteschlange. Kein erneuter Eintrag.', 'debug');
        return;
    }

    try {
        actionQueue.push({ action: desiredState ? 'on' : 'off', brightness: null });
        await processQueue();
    } catch (error) {
        log(`Fehler beim On/Off-Event: ${error}`, 'error');
    }
});

on({ id: datapointBrightness, change: 'ne' }, async (obj) => {
    if (isResetting || obj.state.ack) return;

    const desiredBrightness = obj.state.val;

    // Debug-Logs für `obj.oldState`
    log(`Trigger ausgelöst für Helligkeit:`, 'info');
    log(`- Alter Zustand (obj.oldState): ${JSON.stringify(obj.oldState)}`, 'debug');
    log(`- Alter Wert (obj.oldState.val): ${obj.oldState?.val}`, 'debug');
    log(`- Neuer Wert (obj.state.val): ${desiredBrightness}`, 'debug');

    const oldBrightnessValue = obj.oldState?.val ?? getState(obj.id)?.val ?? 100;

    log(`- Verwendeter alter Helligkeitswert (Fallback berücksichtigt): ${oldBrightnessValue}`, 'debug');

    if (desiredBrightness === oldBrightnessValue) return;

    const actionExists = actionQueue.some(
        (entry) => entry.brightness === desiredBrightness
    );
    if (actionExists) {
        log('Aktion bereits in der Warteschlange. Kein erneuter Eintrag.', 'debug');
        return;
    }

    try {
        if (desiredBrightness < 3) {
            setState(datapointOnOff, false, true);
        } else {
            const brightnessValue = calculateBrightnessHex(desiredBrightness);
            log(`Alter Wert vor Übergabe an writeGattValueWithRetries: ${oldBrightnessValue}`, 'debug');
            actionQueue.push({ action: 'on', brightness: desiredBrightness });
            await processQueue();
        }
    } catch (error) {
        log(`Fehler beim Helligkeits-Event: ${error}`, 'error');
    }
});

async function ensureStateExists(id, initialValue, common) {
    const state = await getObjectAsync(id);
    if (!state) {
        await createStateAsync(id, initialValue, common);
    }
}

await ensureStateExists(datapointOnOff, false, {
    name: 'Lichterkette On/Off',
    type: 'boolean',
    role: 'switch',
    read: true,
    write: true
});

await ensureStateExists(datapointBrightness, 100, {
    name: 'Lichterkette Helligkeit',
    type: 'number',
    role: 'level.dimmer',
    read: true,
    write: true,
    min: 0,
    max: 100
});

(async () => {
    try {
        await activateBluetoothAdapter();
        await processQueue();
    } catch (error) {
        log(`Fehler beim Start des Skripts: ${error}`, 'error');
    }
})();
